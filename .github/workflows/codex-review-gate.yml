name: Codex Review Gate

on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
  pull_request_review:
    types:
      - submitted
      - edited
      - dismissed
  pull_request_review_comment:
    types:
      - created
      - edited
      - deleted

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: codex-review-gate-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  codex-review-gate:
    name: Codex Review Gate
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Require Codex review signal on current PR head
        env:
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          MAX_WAIT_SECONDS: 900
          POLL_INTERVAL_SECONDS: 20
        run: |
          set -euo pipefail

          api_base="https://api.github.com/repos/${REPOSITORY}"
          bot_regex='codex-connector\[bot\]$'
          workflow_path=".github/workflows/codex-review-gate.yml"

          base_file_http_code="$(
            curl -sS -o /tmp/base_gate_workflow.json -w "%{http_code}" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${api_base}/contents/${workflow_path}?ref=${BASE_REF}"
          )"

          if [[ "${base_file_http_code}" != "200" ]]; then
            echo "::warning::Bootstrap mode: ${workflow_path} is not present on base branch ${BASE_REF}."
            echo "::warning::Skipping strict Codex gate for rollout PR. Gate is enforced after merge to base."
            exit 0
          fi

          fetch_paginated_array() {
            local endpoint="$1"
            local page=1
            local all_items='[]'

            while true; do
              local url="${api_base}${endpoint}?per_page=100&page=${page}"
              local resp
              resp="$(curl -fsSL \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "${url}")"

              local count
              count="$(echo "${resp}" | jq 'length')"
              all_items="$(jq -cn --argjson a "${all_items}" --argjson b "${resp}" '$a + $b')"

              if [[ "${count}" -lt 100 ]]; then
                break
              fi
              page=$((page + 1))
            done

            echo "${all_items}"
          }

          commits_json="$(fetch_paginated_array "/pulls/${PR_NUMBER}/commits")"
          head_committed_at="$(echo "${commits_json}" | jq -r --arg sha "${HEAD_SHA}" '
            (.[] | select(.sha == $sha) | .commit.committer.date) // empty
          ')"

          if [[ -z "${head_committed_at}" ]]; then
            echo "::warning::Could not resolve commit timestamp for head ${HEAD_SHA}; using strict commit_id checks only."
            head_committed_at="1970-01-01T00:00:00Z"
          fi

          max_wait="${MAX_WAIT_SECONDS}"
          poll_interval="${POLL_INTERVAL_SECONDS}"
          elapsed=0

          while true; do
            reviews_json="$(fetch_paginated_array "/pulls/${PR_NUMBER}/reviews")"
            review_comments_json="$(fetch_paginated_array "/pulls/${PR_NUMBER}/comments")"
            issue_comments_json="$(fetch_paginated_array "/issues/${PR_NUMBER}/comments")"

            review_count="$(echo "${reviews_json}" | jq --arg sha "${HEAD_SHA}" --arg rx "${bot_regex}" --arg ts "${head_committed_at}" '
              [
                .[]
                | select(
                    (.user.login | test($rx; "i"))
                    and (.state == "COMMENTED" or .state == "APPROVED" or .state == "CHANGES_REQUESTED")
                    and (
                      .commit_id == $sha
                      or ((.submitted_at // "1970-01-01T00:00:00Z") >= $ts)
                    )
                  )
              ] | length
            ')"

            review_comment_count="$(echo "${review_comments_json}" | jq --arg sha "${HEAD_SHA}" --arg rx "${bot_regex}" --arg ts "${head_committed_at}" '
              [
                .[]
                | select(
                    (.user.login | test($rx; "i"))
                    and (
                      .commit_id == $sha
                      or ((.created_at // "1970-01-01T00:00:00Z") >= $ts)
                    )
                  )
              ] | length
            ')"

            issue_comment_count="$(echo "${issue_comments_json}" | jq --arg rx "${bot_regex}" --arg ts "${head_committed_at}" '
              [
                .[]
                | select(
                    (.user.login | test($rx; "i"))
                    and ((.created_at // "1970-01-01T00:00:00Z") >= $ts)
                  )
              ] | length
            ')"

            total_signals=$((review_count + review_comment_count + issue_comment_count))

            echo "review_count=${review_count}"
            echo "review_comment_count=${review_comment_count}"
            echo "issue_comment_count=${issue_comment_count}"
            echo "total_codex_signals=${total_signals}"
            echo "head_sha=${HEAD_SHA}"
            echo "head_committed_at=${head_committed_at}"
            echo "elapsed_seconds=${elapsed}"

            if [[ "${total_signals}" -gt 0 ]]; then
              echo "Codex review gate satisfied for head ${HEAD_SHA}."
              exit 0
            fi

            if [[ "${elapsed}" -ge "${max_wait}" ]]; then
              break
            fi

            sleep "${poll_interval}"
            elapsed=$((elapsed + poll_interval))
          done

          echo "::error::No Codex review signal found on PR #${PR_NUMBER} for head ${HEAD_SHA} within ${max_wait}s."
          echo "::error::Expected chatgpt-codex-connector[bot] signal (review/review-comment/PR comment) for current head."
          exit 1
